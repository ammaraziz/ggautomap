---
title: "Getting started with 'ggautomap'"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with 'ggautomap'}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(nswgeo)
library(ggautomap)
library(ggplot2)
library(dplyr, warn.conflicts = FALSE)
```

This article provides some recipes for plots that might be of interest. These
examples use map data from the `{nswgeo}` package.

Many of the examples use the same example dataset modelled after the structure
of a linelist: rows are distinct events, and they can have a `type` of `A` or `B`.
Each event is associated with a location described at different granularities by
the `postcode`, `lga`, and `lhd` columns.

```{r}
head(covid_cases_nsw)
```

You need to specify which column has the feature by setting the `location`
aesthetic. This example has three different columns of locations for different
feature types; your dataset only needs to have one of these.

In general you'll start with `geom_boundaries()` to draw the base map. This geom
needs to be told which `feature_type` you're after (e.g. `"nswgeo.lga"` for LGAs).
All of the summary geoms of `{ggautomap}` can then be used to draw your data.

## Scatter

```{r scatter, fig.height = 3, fig.width = 7}
covid_cases_nsw %>%
  ggplot(aes(location = lga)) +
  geom_boundaries(feature_type = "nswgeo.lga") +
  geom_geoscatter(aes(colour = type), sample_type = "random", size = 0.5) +
  coord_sf_zoom(datum = NA) +
  theme_minimal()
```

Points are drawn at random within the boundaries of their location.
This example also uses `coord_sf_zoom()` as a replacement for `coord_sf()` that
automatically crops the map around your data points.


## Insets

To show a zoomed in part of the map as an inset, you can configure an inset and
provide it to each relevant geom. The geoms in this package are all inset-aware.
See `{ggmapinset}` for details.

```{r inset, fig.height = 3, fig.width = 7}
covid_cases_nsw %>%
  ggplot(aes(location = lga)) +
  geom_boundaries(feature_type = "nswgeo.lga") +
  geom_geoscatter(aes(colour = type), size = 0.5) +
  geom_inset_frame() +
  coord_automap(feature_type = "nswgeo.lga", datum = NA, inset = configure_inset(
    centre = "Blacktown", radius = 40, units = "km",
    scale = 7, translation = c(400, -100))) +
  theme_minimal()
```

## Packed points

This next example uses `geom_centroids()` to place the points in a
packed circle in the centre of each feature. It also shows how you can
fine-tune the plot with the usual `{ggplot2}` functions.

```{r packed, fig.height = 3, fig.width = 7}
covid_cases_nsw %>%
  filter(year >= 2021) %>%
  ggplot(aes(location = lhd)) +
  geom_boundaries(feature_type = "nswgeo.lhd") +
  geom_centroids(aes(colour = type), position = position_circle_repel_sf(scale = 30), size = 1) +
  geom_inset_frame() +
  coord_automap(datum = NA, inset = configure_inset(
    centre = "Western Sydney", radius = 35, units = "km",
    scale = 8, translation = c(450, -100))) +
  facet_wrap(vars(year)) +
  labs(x = NULL, y = NULL) +
  theme_minimal()
```


## Choropleths

If your data has multiple rows for each location (such as our example dataset where
the rows are disease cases) then you can use `geom_choropleth()` to aggregate these
into counts.

```{r choro-long, fig.height = 3, fig.width = 7}
covid_cases_nsw %>%
  ggplot(aes(location = lhd, group = NA)) +
  geom_choropleth() +
  geom_boundaries(feature_type = "nswgeo.lhd", colour = "black", linewidth = 0.1,
                  outline.aes = list(colour = NA)) +
  geom_inset_frame() +
  coord_automap(datum = NA, inset = configure_inset(
    centre = "Western Sydney", radius = 60, units = "km",
    scale = 3.5, translation = c(350, 0))) +
  scale_fill_steps(low = "#e6f9ff", high = "#00394d", n.breaks = 5, na.value = "white") +
  theme_minimal()
```

On the other hand, if your dataset has only one row per location and there is an
existing column that you'd like to map to the `fill` aesthetic, then instead use
`geom_sf_inset(..., stat = "automap")`:

```{r choro-wide, fig.height = 3, fig.width = 7}
summarised_data <- data.frame(
  lhd = c("Western Sydney", "Sydney", "Far West", "Mid North Coast", "South Western Sydney"),
  cases = c(250, 80, 20, NA, 100)
)

summarised_data %>%
  ggplot(aes(location = lhd, group = NA)) +
  geom_sf_inset(aes(fill = cases), stat = "automap", colour = NA) +
  geom_boundaries(feature_type = "nswgeo.lhd", colour = "black", linewidth = 0.1,
                  outline.aes = list(colour = NA)) +
  geom_inset_frame() +
  coord_automap(datum = NA, inset = configure_inset(
    centre = "Western Sydney", radius = 60, units = "km",
    scale = 3.5, translation = c(350, 0))) +
  scale_fill_gradient(low = "#e6f9ff", high = "#00394d", na.value = "grey90") +
  theme_minimal()
```


## Pies charts

The `"nswgeo.states"` map data includes the other states for national summaries.
Both the abbreviated state names (e.g. `"NSW"`) and the full names (e.g.
`"New South Wales"`) are supported in the `location` aesthetic.
This example also shows `geom_pie()`, which aggregates points in each location.

```{r pies}
national_data <- data.frame(state = sample(c("qld", "nsw", "vic", "sa", "act"),
                                           size = 1000, replace = TRUE,
                                           prob = c(0.2, 0.35, 0.3, 0.1, 0.05)),
                            type = sample(c("A", "B", "C"),
                                          size = 1000, replace = TRUE,
                                          prob = c(0.3, 0.6, 0.1)))
national_data$type[national_data$state == "act"] <- "A"

national_data %>%
  ggplot(aes(location = state)) +
  geom_boundaries(feature_type = "nswgeo.states") +
  geom_pie(aes(fill = type), pie_radius = 1.5) +
  coord_sf(datum = NA) +
  theme_minimal()
```
